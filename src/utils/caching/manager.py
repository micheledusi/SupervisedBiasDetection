# - - - - - - - - - - - - - - - #
#   Supervised Bias Detection   #
#								#
#   Author:  Michele Dusi	 	#
#   Date:	2023				#
# - - - - - - - - - - - - - - - #

# This module offers some utils functions for caching data.

import copy
from datetime import datetime
import json
import logging
import os
from typing import Any, Callable

from data_processing.types import CachedDataType


class CacheManager:
	"""
	This class offers some utils functions for caching data.
	Each data can be saved along with a unique identifier and some metadata.
	Then, the data can be retrieved by providing the unique identifier and the metadata.
	"""
	DEFAULT_ROOT_DIR: str = 'cache'
	REGISTER_FILENAME: str = 'register.json'

	def __init__(self, root_dir: str = DEFAULT_ROOT_DIR) -> None:
		self.root: str = root_dir

	def _get_folder(self, datatype: CachedDataType) -> str:
		"""
		This method returns the folder where the data of the given type are saved.

		:param datatype: The type of the data.
		:return: The folder where the data of the given type are saved, as a string.
		"""
		return self.root + '/' + datatype.folder_name
	
	def _get_register_filepath(self, datatype: CachedDataType) -> str:
		"""
		This method returns the filepath of the register file of the given type.

		:param datatype: The type of the data.
		:return: The filepath of the register file of the given type, as a string.
		"""
		return self._get_folder(datatype) + '/' + self.REGISTER_FILENAME

	def _init_folder(self, datatype: CachedDataType) -> None:
		"""
		This method initializes a new folder of data according to their type, i.e. the directory where the data will be saved.
		If the group already exists, this method does nothing.
		If the directory where the data will be saved does not exist, this method creates it.
		Plus, this method creates a file containing the register of the group, called 'register.json'.

		:param group: The name of the group.
		:return: None.
		"""
		# If the group directory does not exist, create it.
		if not os.path.exists(self._get_folder(datatype)):
			os.makedirs(self._get_folder(datatype))
		# If the register file does not exist, create it.
		if not os.path.exists(self._get_register_filepath(datatype)):
			with open(self._get_register_filepath(datatype), 'w') as f:
				f.write('[]')

	@staticmethod
	def _hash_dict(obj: Any) -> int:
		"""
		Makes a hash from a dictionary, list, tuple or set to any level, that contains
		only other hashable types (including any lists, tuples, sets, and
		dictionaries).
		"""
		if isinstance(obj, (set, tuple, list)):
			return tuple([CacheManager._hash_dict(elem) for elem in obj])	
		elif not isinstance(obj, dict):
			return hash(obj)
		new_o = copy.deepcopy(obj)
		for k, v in new_o.items():
			new_o[k] = CacheManager._hash_dict(v)
		return hash(tuple(frozenset(sorted(new_o.items()))))

	def _compute_filename(self, datatype: CachedDataType, metadata: dict[str, Any]) -> str:
		"""
		This method computes the filename of an object with a given datatype and metadata.
		The filename is generated by hashing the metadata and the datatype name.

		:param datatype: The type of the object.
		:param metadata: The metadata of the object, as a dictionary.
		:return: The filename of the object, as a string representing the hash of data definition.
		"""
		descriptor = metadata.copy()
		descriptor['datatype'] = datatype.name
		return str(hex(abs(CacheManager._hash_dict(descriptor))))

	def _register(self, filename: str, datatype: CachedDataType, metadata: dict[str, Any]) -> None:
		"""
		This method register a new object in the correct group (defined as the datatype).
		The registration writes in the group register file (a JSON file) the metadata of the object.
		Default metadata are added to the given metadata, such as:
		- the saving timestamp;
		
		This method does not save the object itself.
		This method does not check if the object already exists.
		This method does not check if the group exists: it is the caller's responsibility to check it and to create the group if necessary.

		:param filename: The filename of the object, generated by the hash of the metadata (see method ``save``)
		:param datatype: The type of data, containing all the information on the group.
		:param metadata: The metadata of the object, as a dictionary
		:return: None.
		"""
		register = json.load(open(self._get_register_filepath(datatype), 'r'))
		assert isinstance(register, list)

		# If corresponding objects already exist, we remove them
		def is_corresponding(entry):
			return entry['metadata'] == metadata
		annotated_register = map(lambda entry: (entry, is_corresponding(entry)), register)
		register = []
		for entry, to_be_deleted in annotated_register:
			if not to_be_deleted:
				register.append(entry)
			else:
				logging.info("Removing old object from cache:%s", entry['filename'])
				try:
					datatype.filestream.delete(self._get_folder(datatype) + '/' + entry['filename'])

				# That is a patch, it will be changed in the future.
				# The problem is that the file exists, but can have the old extension (e.g. .pkl)
				# In that case, we re-call the method with the old extension.
				except FileNotFoundError:
					try:
						datatype.filestream.delete(self._get_folder(datatype) + '/' + entry['filename'], extension='.pkl')
					except FileNotFoundError:
						logging.error("File not found in cache:%s", entry['filename'])

		# "register" has now been cleaned from the corresponding objects (if any)
		# Also, the corresponding files have been deleted from the cache.

		# Adding the new object to the register
		register.append({
			'filename': filename,
			'timestamp': str(datetime.today()),
			'metadata': metadata
		})
		# Saving the register
		json.dump(register, open(self._get_register_filepath(datatype), 'w'), indent=4)

	def save(self, data: Any, datatype: CachedDataType, metadata: dict[str, Any] | None = None) -> None:
		"""
		This method saves the given data along with the given identifier and metadata.
		The data is saved in a pickle file, and the metadata is saved in the group register file.

		:param data: The data to save.
		:param datatype: The type of data, containing all the information on the group.
		:param metadata: The metadata of the object to save (optional; default: None)
		:return: None.
		"""
		# Asserting that the group exists
		self._init_folder(datatype)
		# Asserting the metadata are a dictionary
		if not metadata:
			metadata = dict()
		# Computing the filename
		filename = self._compute_filename(datatype, metadata)
		# Registering the object to the group register
		self._register(filename, datatype, metadata)
		# Saving the data
		datatype.filestream.write(self._get_folder(datatype) + '/' + filename, data)

	def exists(self, datatype: CachedDataType, metadata: dict[str, Any] | None = None) -> bool:
		"""
		This method checks if the object with the given identifier, group and metadata exists.
		If the object exists, this method returns True.
		If the object does not exist, this method returns False.

		:param datatype: The type of the object to check.
		:param metadata: The metadata of the object, as a dictionary (optional; default: None)
		:return: True if the object exists, False otherwise.
		"""
		if not metadata:
			metadata = dict()

		# If the group does not exist, the object does not exist
		if not os.path.exists(self._get_folder(datatype)):
			return False
		# If the register file does not exist, the object does not exist
		if not os.path.exists(self._get_register_filepath(datatype)):
			return False
		# If the object is not in the register, the object does not exist
		register = json.load(open(self._get_register_filepath(datatype), 'r'))
		assert isinstance(register, list), "Something's wrong: the register file is not a list."
		for obj in register:
			if obj['metadata'] == metadata:
				return True

	def _retrieve_filename(self, datatype: CachedDataType, metadata: dict[str, Any]) -> str | None:
		"""
		This method returns the filename of the object with the given identifier and metadata.
		If the object does not exist, this method returns None.

		:param datatype: The type of the object to retrieve.
		:param metadata: The metadata of the object, as a dictionary (optional; default: None)
		:return: The filename of the object, or None if the object does not exist.
		"""
		# Checking if the object exists
		if not self.exists(datatype, metadata):
			return None
		# Searching
		register = json.load(open(self._get_register_filepath(datatype), 'r'))
		assert isinstance(register, list), "Something's wrong: the register file is not a list."
		for obj in register:
			if obj['metadata'] == metadata:
				return obj['filename']
		return None
	
	def load(self, datatype: CachedDataType, metadata: dict[str, Any] | None = None) -> Any:
		"""
		This method loads the object with the given identifier and metadata.
		If the object does not exist, this method raises an exception.

		:param datatype: The type of the object to load.
		:param metadata: The metadata of the object, as a dictionary (optional; default: None)
		:return: The object.
		"""
		# Checking if the object exists
		if not metadata:
			metadata = dict()
		# The check on the specific object is done in the `_retrieve_filename` method
		filename = self._retrieve_filename(datatype, metadata)
		if not filename:
			raise Exception(f"The object of type {datatype.name} with metadata {metadata} does not exist in the cache.")

		# Loading the object
		obj = datatype.filestream.read(self._get_folder(datatype) + '/' + filename)
		return obj


class CachedData:
	def __init__(self, datatype: CachedDataType, metadata: dict[str, Any], creation_fn: Callable = None, rebuild: bool = False) -> None:
		"""
		This class is a context manager that can be used to cache data.
		If the data does not exist in the cache, it is created using the given creation function.
		If the data exists in the cache, it is loaded from the cache.

		:param datatype: The type of the data to cache.
		:param metadata: The metadata of the object.
		:param creation_fn: The function to call to create the object if it does not exist in the cache (optional; default: None)
		:param rebuild: If True, the object is always created from scratch (optional; default: False)
		"""
		self._datatype: CachedDataType = datatype
		self._metadata: dict[str, Any] = metadata
		self._creation_fn: Callable = creation_fn
		self._rebuild: bool = rebuild
		self._cacher: CacheManager = CacheManager()

	def __enter__(self):
		if not self._rebuild and self._cacher.exists(self._datatype, self._metadata):
			try:
				logging.info(f"Loading cached data of type: \"{self._datatype.value}\"")
				return self._cacher.load(self._datatype, self._metadata)
			except FileNotFoundError as e:
				logging.error(f"File not found for cached data of type: \"{self._datatype.value}\": {e}")
		# Otherwise
		if self._creation_fn is None:
			raise NotImplemented("The creation function is not defined, and the object does not exist in the cache.")
		else:
			logging.info(f"Creating data of type \"{self._datatype}\" from scratch and saving to the cache")
			data = self._creation_fn()
			self._cacher.save(data, self._datatype, self._metadata)
			return data
	
	def __exit__(self, *args):
		pass